# Finite Automata

### Course: Formal Languages & Finite Automata
### Author: Miricinschi Gabriel, FAF-233

----

## Theory

A finite automaton is a computational model used to represent various processes, ranging from simple control systems to complex pattern recognition mechanisms. It operates similarly to a state machine, as both are structured around states and transitions that define how a system moves from one configuration to another based on inputs. The term finite highlights that the automaton consists of a limited number of states, including a well-defined starting state and one or more final states, which signify valid completion points of a given process. In essence, an automaton models a system with a clear beginning and end, making it a useful abstraction in computing, linguistics, and engineering.

Within the structure of an automaton, there are scenarios where a single transition can lead to multiple possible states, introducing non-determinism into the system. In the broader context of systems theory, the concept of determinism refers to the predictability of a system’s behavior—if a system always produces the same outcome given a specific input, it is deterministic; otherwise, if randomness or multiple outcomes are possible, it becomes stochastic or non-deterministic.

Because of this distinction, finite automata can be categorized as either deterministic or non-deterministic. Despite the presence of non-determinism in some automata, there exist well-defined algorithms that allow the transformation of a non-deterministic finite automaton (NFA) into an equivalent deterministic finite automaton (DFA). This conversion process ensures that for every input symbol, there is a single, unique transition from each state, making the system fully predictable and structured. This ability to refine and restructure automata plays a crucial role in theoretical computer science, formal language processing, and the design of efficient computational models.

## Objectives:

1. Understand what an automaton is and what it can be used for.

2. Continuing the work in the same repository and the same project, the following need to be added:
    a. Provide a function in your grammar type/class that could classify the grammar based on Chomsky hierarchy.

    b. For this you can use the variant from the previous lab.

3. According to your variant number (by universal convention it is register ID), get the finite automaton definition and do the following tasks:

    a. Implement conversion of a finite automaton to a regular grammar.

    b. Determine whether your FA is deterministic or non-deterministic.

    c. Implement some functionality that would convert an NDFA to a DFA.
    

## Implementation description

This part in the Grammar class converts a grammar into a finite automaton (FA) by mapping each non-terminal to a unique state and defining transitions based on the production rules. It iterates through the rules, assigning states to non-terminals if they haven't been mapped yet. For each production, if the rule contains both a terminal and a non-terminal (X → aY), it ensures the next non-terminal has a corresponding state and sets up a transition. If the production consists of only a terminal (X → a), the current state's transition leads to itself, and the FA marks it as a final state. This ensures that the FA properly recognizes strings generated by the grammar. Once all transitions are processed, the function returns the constructed FA.

```c++
    // For each non-terminal, create a state and handle transitions
    for (auto& rule : rules) {
        char nonTerminal = rule.first;
        if (stateMapping.find(nonTerminal) == stateMapping.end()) {
            stateMapping[nonTerminal] = "q" + to_string(stateCount++);
        }

        for (const string& production : rule.second) {
            char symbol = production[0];  // Terminal symbol
            string nextState;

            if (production.size() == 2) {  // Non-terminal transition (i.e., second character)
                char nextNonTerminal = production[1];
                if (stateMapping.find(nextNonTerminal) == stateMapping.end()) {
                    stateMapping[nextNonTerminal] = "q" + to_string(stateCount++);
                }
                nextState = stateMapping[nextNonTerminal];
            } else {  // Terminal transition
                nextState = stateMapping[nonTerminal];
                fa.finalStates.insert(nextState);  // This should be marked as final for terminal symbols
            }
```
This code is part of the FiniteAutomaton class and contributes to a function that converts a non-deterministic finite automaton (NFA) into a deterministic finite automaton (DFA). The function iterates over all symbols in the alphabet and computes the transitions for each state in the DFA. It does this by checking which states in the NFA can be reached from the current set of states and grouping them into a new DFA state. The new state is represented by concatenating the names of the NFA states it includes. If the newly formed state hasn't been processed yet, it's added to the queue for further processing. The function ensures that every transition in the DFA leads to a unique state, eliminating non-determinism. Additionally, a separate function in the class checks whether the FA is deterministic, allowing verification before conversion. Once all states and transitions are processed, the function returns a new FA object that represents the equivalent DFA.

```c++
        // For each symbol in the alphabet, compute transitions
        for (char symbol : alphabet) {
            set<string> newStateSet;
            for (const string& s : currentSet) {
                if (transitions.count({s, symbol})) {
                    newStateSet.insert(transitions[{s, symbol}].begin(), transitions[{s, symbol}].end());
                }
            }

            if (!newStateSet.empty()) {
                // Create new state name by concatenating NFA states in the set
                string newStateName = "";
                for (const string& s : newStateSet) {
                    newStateName += s;  // Concatenate each string from the set
                }

                // Add transition in DFA from current state to new state
                dfa.transitions[{stateName, symbol}].insert(newStateName);

                // If this new state hasn't been processed, enqueue it
                if (!processedStates.count(newStateName)) {
                    newStates.push(newStateSet);
                    stateMapping[newStateName] = newStateSet;
                }
            }
```
## Conclusions
In this lab, I enhanced the Grammar class to define formal grammars using production rules and integrated functionality to convert the grammar into a Finite Automaton (FA). Additionally, I implemented methods in the FiniteAutomaton class to check for determinism and convert an NFA to a DFA. This work deepened my understanding of formal languages, grammars, and finite automata, particularly in their application for language generation, validation, and automaton conversions. The tasks reinforced how these theoretical concepts are connected and provided practical experience in working with them through programming.

### Output

![Results](https://github.com/user-attachments/assets/92134b18-87a9-448f-88c1-e98c6557d2d8)

Results after running the code.
